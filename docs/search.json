[
  {
    "objectID": "module1.html",
    "href": "module1.html",
    "title": "Module 1: Bash terminal basics",
    "section": "",
    "text": "This module will cover the basics of navigating the bash terminal"
  },
  {
    "objectID": "module1.html#exploring-the-file-system",
    "href": "module1.html#exploring-the-file-system",
    "title": "Module 1: Bash terminal basics",
    "section": "Exploring the file system",
    "text": "Exploring the file system\nTo ‘move’ around your computer, typically you would use the built-in file explorer, where you would point and click to navigate through different files and folders.\nWe can also perform the same actions from the terminal by simply typing out the PATH to each file or folder\nThe PATH to a file is the exact location of that file on the computer.\nIt is very important to know at all times exactly where you are in the file system as well as where the files you are working with are.\n\nThe working directory\nOpen the terminal and create an empty file\ntouch example.txt\nWe created a file called example.txt using the touch command. Here, we simply specified the name of the file to be created, but did NOT specify where the file should be created. This means, the file got created in the WORKING DIRECTORY.\nIf you are creating or referring to a file without specifying the PATH , your computer will assume you are pointing to the current WORKING DIRECTORY.\nThe WORKING DIRECTORY refers to the directory you are currently in.\nThe WORKING DIRECTORY can also be signified as ./ .\nWhile ./ will always point to the current WORKING DIRECTORYy, it is merely a shorthand that is referring to the actual PATH to your WORKING DIRECTORY directory.\nThe pwd command or ‘Print Working Directory’ prints the path to the current working directory. It might look something like this\npwd\n/mnt/c/Users/username/project\n\nThe path to any location always starts with / which signifies the root directory. The root is the starting location and it is as far back in the filesystem as you can go.\nIf you imagine the filesystem as a tree with each branch being a different folder, the root directory is the base of the tree trunk\nFrom the root directory /, we are inside the directory mnt, followed by c, followed by Users and so on.\nWhen we created example.txt, we created it from the project directory.\nThis means, the PATH to example.txt is\n\n/mnt/c/Users/username/project/example.txt\n\n\n\n\n\n\nDirectory vs. Folder\n\n\n\nBoth are generally used interchangably though directory is the technically correct term.\n\n\n\n\nThe home directory\nWhen you open your terminal, your default location will be your HOME directory\nThis can be signified as ~/ .\nWhile ~/ will always point to your default HOME directory, it is merely a shorthand that is referring to the actual PATH to your HOME directory.\nThis path can be seen using:\necho $HOME\n/mnt/c/Users/username\n\nThe echo command simply prints out the following text\n$HOME refers to the built-in variable called HOME\n$HOME contains a value, which is the path to your HOME directory\nIn this case, my home directory is /mnt/c/Users/username\nSo if I want to point to example.txt, another way for me to do it is:\n\n~/project/example.txt\n\n\nChanging directories\nThe cd command (or “change directory”) allows you to move between different directories\nFor example, if we would like to move to our home directory, we can type\ncd ~/\n\n\n\n\n\n\nNote\n\n\n\nIn the above example, you would directly move to your home directory no matter where in the filesystem you were, as ~/ always refers to your home directory.\n\n\nNow our current working directory is our home directory.\nIf we would like to switch to the project directory, we can type\ncd project\nWe can move out one level from the current working directory using ../ . Similar to how ./ always refers to the current directory, ../ always refers to one directory above the current directory.\nFor example, if our current directory is /mnt/c/Users/username/project/\ncd ../\npwd\n/mnt/c/Users/username/\ncd ../ takes us one directory above project, which in this case is username. If we were to repeat this, we would go up one more directory, taking us to Users:\ncd ../\npwd\n/mnt/c/Users/\nTherefore ./ and ../ are shorthands that refer to paths that change depending on the current working directory. In other words, they are RELATIVE .\n\nAbsolute vs. Relative Paths\nThere are two main types of paths when referring to files and directories: ABSOLUTE and RELATIVE paths.\nAbsolute Paths always start from the root directory / and specify the exact location of a file or folder in the filesystem. For example, the absolute path to example.txt is:\n/mnt/c/Users/username/project/example.txt\nRelative Paths are paths that are relative to the current working directory. For instance, if you are currently in the username directory, you can refer to example.txt by:\n./project/example.txt\nIf you are in project , and you want to refer to another file another_example.txt that is in Users, you can refer to it relative to your current location such as\n../../another_example.txt\n../../ goes two levels above project to reach Users and then refers to another_example.txt .\n\n\n\n\n\n\nWhy You Should Practice Using Absolute Paths\n\n\n\nIt’s generally a good idea to use absolute paths when you’re working with files or directories, especially when writing scripts or commands that could be run from different locations. This ensures that you are always referring to the exact file, no matter where you are in the filesystem.\n\n\n\n\nThe autocomplete feature\nWhen you are typing out filenames or directory names in the shell, it will attempt to automatically complete what you are typing with the file/directory names WITHIN THE DIRECTORY YOU ARE CURRENTLY IN. For example, say you want to change to the directory /mnt/c/Users/username/ .\nWhen you begin typing /mnt/c/Users/us and then press the tab (⭾) button on your keyboard, it will automatically complete to /mnt/c/Users/username/ .\nIf you have multiple folders that begin with user, it will complete to the furthest possible character. For example if you have the following files in your Users directory\n$: ls Users\n\nuser1 user2 username\nThe autocomplete feature will complete /mnt/c/Users/us to /mnt/c/Users/user, after which you can type n to make it /mnt/c/Users/usern and then press tab again, which will then complete it to /mnt/c/Users/username\nThe autocomplete feature works the same way for files, for example /mnt/c/Users/username/project/exa will complete to /mnt/c/Users/username/project/example.txt .\n\n\n\n\n\n\nThe shell is CASE-SENSITIVE\n\n\n\nexample.txt and Example.txt will be treated as different files. If you type exa and press tab, it will never complete to Example.txt.\n\n\n\n\n\nOther useful commands\n\nmkdir : Makes a new directory called dir1 in the current directory (project)\nmkdir dir1\nI recommend making a separate project directory (or any name of your choosing) for this workshop to perform all upcoming exercises.\n\n\n\n\n\n\nDO NOT USE SPACES IN FILE/FOLDER NAMES\n\n\n\nIn general it is good practice to not use spaces or special characters ( such as ?!&lt;&gt;,[]{}() ) in your file or folder names as usually, spaces and special characters have a SPECIAL MEANING in the command line and stand for specific operations. This can lead to the system getting confused when you for example refer to a folder with a special character, as it will assume you are performing an operation that the character stands for. For example, the space character is usually the separator for different options/modifiers for command line tools. Use _ instead of spaces.\n\n\n\n\nls : Lists all contents in the specified directory.\nIn the below example we list all the contents in the directory project\nls /mnt/c/Users/username/project/\ndir1\nexample.txt\n\n\ncp : Creates a copy of a file.\nThe below example copies example.txt to dir1 .\ncp example.txt ./dir1/  \n\n\nmv : Moves a file from one location to another.\nThe below example moves example.txt from dir1 to dir2.\nmkdir dir2\nmv ./dir1/example.txt ./dir2/  \n\n\ncat : Display all the contents within a file.\nTo display all the contents that is within example.txt:\nls cat example.txt\nIn our case since we did not write anything into example.txt it will be empty. Feel free to open example.txt in your text editor, write some text into it and then try out the cat command.\n\n\nhead and tail : Display the first n or last n lines in a file\nBy default head or tail will display the first 10 or last 10 lines of a file.\nhead example.txt \n\n\nrm : Removes (delete) a specified file. In the below example we delete example.txt in dir2\nrm /mnt/c/Users/username/project/dir2/example.txt\n\n\n\n\n\n\nREMOVING IS PERMANENT\n\n\n\nBe very careful when using the rm command as there will be no confirmation dialogue box asking you if you are sure you want to delete the file as you might be used to. The file will simply PERMANENTLY be deleted!\n\n\n\n\nman: Shows the manual (help) page for any command.\nYou can also follow any command with either -h or --help to display the help page. Look up the help page of the above commands to see all the different ways they can be used!\nman ls\nls --help\nFeel free to experiment with the above commands, navigating between different folders, creating and moving files, using absolute and relative paths and so on.\nYou can also add modifiers to each command to slightly change its behaviour. For example ls simply lists the names of all the files in the specified directory but ls -l lists them with a lot more additional information! You can also use multiple modifiers at a time like ls -l -a (What does -a do?) . Make sure to look into the --help pages for the commands to know more.\n\n\n\nEXERCISE: Try to find the modifiers for each of the commands above to do the following :\n\nList files along with the file sizes\n\n\n\nClick to reveal answer\n\nls -sh\n\n\nList files sorted by the time they were created\n\n\n\nClick to reveal answer\n\nls -lt\n\n\nPrint the first 30 lines from a file\n\n\n\nClick to reveal answer\n\nhead -n 30 filename.txt\n\n\nPrint all lines starting from the 3rd line\n\n\n\nClick to reveal answer\n\ntail -n +3 filename.txt\n\n\nCopy or move a directory along with all the contents\n\n\n\nClick to reveal answer\n\ncp -r /path/to/dir /path/to/new_dir\n\n\nDelete a directory\n\n\n\nClick to reveal answer\n\nrm -r /path/to/dir"
  },
  {
    "objectID": "module1.html#files-and-file-extensions",
    "href": "module1.html#files-and-file-extensions",
    "title": "Module 1: Bash terminal basics",
    "section": "Files and File Extensions",
    "text": "Files and File Extensions\nEvery file on your computer has a file extension, which is part of its name and comes after the last period (dot) in the filename. For example, in example.txt, .txt is the file extension.\nFile extensions are used by the operating system to determine what kind of file it is, what program should open it, and how it should be processed. Some common file extensions include:\n\n.txt - Text file\n.csv - A table/dataframe with comma separated values\n.docx - Microsoft Word document\n.pdf - PDF document\n.jpg - JPEG image file\n.sh - Shell script\n\n\nWhy Are File Extensions Important?\nFile extensions are important because they help the system identify how to handle a file. For example: - A .txt file is usually opened with a simple text editor (e.g., Notepad, VSCode, etc.). A .docx file is typically opened in Microsoft Word or similar word processing software.\n\n\n\n\n\n\nNote\n\n\n\nThe extension does not determine the content of a file, just how it is generally interpreted by the system. You can change a file extension, but it doesn’t change the underlying content, though it might prevent the file from being opened correctly. For example you can change the extension of a .jpg image to .txt , but that doesn’t mean you can open it in Notepad as it will still be an image.\n\n\n\n\nPlain Text Files\n\nWhat is Plain Text?\nPlain text files contain ONLY text. There is no additional formatting (such as bold/italics/colours), images, or embedded metadata. These files can be created and edited with simple text editors such as NotePad (Windows), TextEdit (MacOS), gedit (Ubuntu)\n\n\n\n\n\n\nNote\n\n\n\nA word/google docs document with only text still is not a plain text file. They still have a lot of embedded formatting and metadata.\n\n\nPlain text is UNIVERSAL. It is not a proprietary format that can only be read by specific programmes (for example, .docx). Any text editor across any system can read and manipulate plain text files.\nIn bioinformatics, plain text files are preferred for storing data because they can be easily read, processed, and manipulated by a variety of different software. Scripts for some programming languages such as Python, Bash, and R are also in plain text format.\nHowever, not all bioinformatics data comes in plain text. Many data formats are designed for efficient storage, performance, or specific analysis tasks, and they may be binary formats (e.g., BAM). In bioinformatics workflows, plain text formats are still commonly used for various data exchange and reporting.\n\n\n\n\n\n\nNote\n\n\n\nFor some programming languages, the scripts need to be compiled before they can be executed (for eg: C, Rust). While the script itself will be in plain-text, it cannot be executed unless it is compiled into a binary. In the case of Python, R and Bash, compilation is not needed.\n\n\nHere are some of the most common plain text files used in bioinformatics:\n\n\n1. .csv or .tsv\nThis will probably be the most common file format you will be directly interacting with on a regular basis. csv (Comma Separated Values) or tsv (Tab separated values) are used to store tabular data with commas (in csv) or tabs (in tsv) as the separator in-between values in the table. In other words, it is a way to represent a table in plain-text, with rows separated by new lines and columns separated by commas or tabs. This separator is referred to as the delimiter, with tsv files also being referred to as tab delimited files and csv as comma delimited. Many of the common bioinformatic file formats we will be discussing below are also tab delimited files.\nExample .tsv file:\nsample_name   Gene_symbol   Sequence_name\nSAMN09634554    sseK2   type III secretion system effector arginine glycosyltransferase SseK2\nSAMN42760649    mdsB    multidrug efflux RND transporter permease subunit MdsB\nSAMN07714001    golT    gold/copper-translocating P-type ATPase GolT\nSame example as a .csv\nsample_name,Gene_symbol,Sequence_name\nSAMN09634554,sseK2,type III secretion system effector arginine glycosyltransferase SseK2\nSAMN42760649,mdsB,multidrug efflux RND transporter permease subunit MdsB\nSAMN07714001,golT,gold/copper-translocating P-type ATPase GolT\n\n\n\n\n\n\nNote\n\n\n\nA .csv or .tsv may not be the most convenient way for us to visualize a table compared to software like excel that neatly separate each value into individual cells, however when you are working with large datasets having thousands to millions of rows, these format enable extremely fast and efficient processing of the data. Moreover, several bioinformatics tools will use .csv and/or .tsv files as their inputs or outputs. So it is very important you are familiar with handling these files.\n\n\n\n\n2. FASTA\n\nFASTA is one of the most widely used formats for representing biological sequences, such as DNA, RNA, or protein sequences. A FASTA file can consist of multiple sequences. Each entry in a FASTA file has two components :\n\nDescription line: Starts with &gt;, followed by an identifier and optional description.\nSequence: The actual sequence of nucleotides (DNA) or amino acids (protein). The sequence can be in a single line or broken up into multiple lines.\n\nExtensions: .fasta,.fna,.fa,.faa\n\nExample FASTA format:\n&gt;HNLNHC_00005 Oxaloacetate decarboxylase\nGTGCGCGAGGACCTTGGCTTTATCCCGCTGGTGACCCCCACTTCACAGATT\nGTCGGCACCCAGGCGGTGCTCAACGTCCTGACCGGCGAACGCTACAAAACC\n\n&gt;HNLNHC_00010 Oxaloacetate decarboxylase beta chain 2\nATGGAAAGTCTGAACGCCCTGCTTCAGGGCATGGGGCTGATGCACCTTGGC\nGCAGGCCAGGCCATCATGCTGCTGGTGAGCCTGCTGCTGCTGTGGCTGGCG\n\n\n3. FASTQ\n\nThe FASTQ format is an extension of the FASTA format, used for storing raw sequence data with quality scores. Each entry contains four lines:\n\nHeader: Starts with @ followed by the sequence identifier.\nSequence: The actual sequence of nucleotides.\nPlus line: Starts with a + sign (may also followed by the same sequence identifier)\nQuality scores: Per-base quality score corresponding to the sequence in line 2. Each symbol here corresponds to a numeric score for the base call in the corresponding position. Learn more about quality scores here.\n\nExtensions: .fastq,.fq . Typically paired-end fastq reads for a single sample will have the suffix _R1.fastq and _R2.fastq.\n\nExample FASTQ format:\n@SRR16006951.1 1 length=149\nCTGTTCGATATTGCCGCCTTGCGCCCCGCGCCGCTCACCCCGCTGGTGGCATTAATTACCGGCCACTGCGTCAGATCCAAAAGACCGCCGTCAATCAGCGGTTTTAGCGACAACTGCGCTGCGGTTGGATAGCAACCAGGAACCGCAAT\n+SRR16006951.1 1 length=149\nAAAAAEEEEEEAEAEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE/EEEEEEEEEAEEEEEEEEEEAAEAEEEEEEEEEEEEEEEEEEAAEEEEEEEEEEEEEEEEEEEEEEEA&lt;/EEEEE/&lt;EAAAE/&lt;\n@SRR16006951.2 2 length=148\nGTCGCCGTGTTTCTCTCCTTTGATGGCGAACTCGACACCCAGCCGCTGATAGAACAGCTATGGCAAGCGGGCAAGCGCGTCTACCTTCCGGTTCTTCATCCCTTCAGCCCTGGCAACCTCCTGTTCCTGCACTATCATACGCAGAGTG\n+SRR16006951.2 2 length=148\nAAAAAEEEEAEE/EEE/EAEEAEEAEEEEEEA&lt;AEEEEEE//EEAE&lt;EEEA/EE&lt;EAEEEA&lt;AEEE/E&lt;EEEEEAEAE&lt;EA/E&lt;A6E/E/E/E/&lt;E/E&lt;/&lt;A/E&lt;&lt;/EEE/&lt;EE/EAE//A/&lt;&lt;E/E/6&lt;EA/A&lt;/A//&lt;/AE/E/E/\n\n\n5. GFF\n\nGFF or General Feature Format is a tab delimited file with information about genes and other features from a FASTA file.\nOnce a FASTA file is annotated i.e by running some kind of gene finding/functional annotation software, specific regions in the fasta file will be identified as genes (or other genetic features such as non-coding RNA, tRNA and so on)\nA GFF file may vary depending on exactly how it was generated but in general it has the following columns:\n\nMetadata lines starting with ##\nSequence ID/contig ID that was annotated\nThe specific feature (CDS/ncRNA etc)\nThe start and end positions of the feature on the contig\nMore details regarding the annotation\n\nExtensions: .gff, .gff3\n\nExample GenBank format : [\n##gff-version 3\n##feature-ontology https://github.com/The-Sequence-Ontology/SO-Ontologies/blob/v3.1/so.obo\ncontig_1    CDS     90      1232    ID=HCEKFJ_00005;Name=Biotin/lipoyl-binding protein;product=Biotin/lipoyl-binding protein;\ncontig_46   ncRNA   1728    1828    ID=HCEKFJ_23455;Name=RNAI;gene=RNAI;product=RNAI;\n\n\n4. GenBank\n\nGenBank is also a gene feature/annotation format containing information about genes and other features, but is larger and contains more information than the gff file. For eg:\n\nInformation regarding the person/institution that generated the file with contact information\nIf the record is connected to a specific publication\nAmino acid sequences for each annotated gene.\n\nExtensions: .gbk, .gbff\n\nExample GenBank format : NCBI Sample Genbank Record\n\n\n6. SAM/BAM\n\nSAM (Sequence Alignment/Map) is a tab delimited with information about the alignment of sequences to a reference genome.\nDepending on how the SAM file was generated, the formatting can vary slightly but the first few columns are mandatory. In general all SAM files have\n\nThe identifier of read that was mapped\nThe SAM flag describing certain properties of the mapped read\nThe reference contig ID, mapping quality\nThe mapping position\nA compressed representation of the alignment called CIGAR (for eg: if any insertions/deletions are present and at what position)\n\nSee here for a more detailed explanation of SAM files.\nBAM is the binary equivalent of SAM. BAM files are not in plain-text, they are compressed (and usually also indexed) versions of SAM files. This would make BAM files more efficient in terms of storage and allows fast querying for alignments across specific positions without having to search through the whole file.\n\nExtensions: .sam, .bam . A BAM index will have the extention .bai\n\nExample SAM format:\n@HD VN:1.6 SO:coordinate\n@SQ SN:ref LN:45\nr001 99 ref 7 30 8M2I4M1D3M = 37 39 TTAGATAAAGGATACTG *\nr002 0 ref 9 30 3S6M1P1I4M * 0 0 AAAAGATAAGGATA *\nr003 0 ref 9 30 5S6M * 0 0 GCCTAAGCTAA * SA:Z:ref,29,-,6H5M,17,0;\n\n\n7. VCF\n\nVCF or Variant Call Format is a tab delimited file derived from the SAM file and comprises specifically genetic variation data after alignment.\nA VCF file contains file metadata (lines starting with ##) followed by genetic variants (SNPs/indels) at each position when compared to the reference.\nIn the example below, you can see that the lines starting with ## have information about the file and the INFO and FORMAT columns\nSimilar to the SAM file, the VCF file can have slight differences depending on how it was generated but the first few columns are mandatory.\nFor eg: A vcf file generated from an alignment against an annotated reference will also provide the functional nature of the variant, for eg: if a SNP was found in a coding region, the VCF file will have additional information (eg: Synonymous/Non-synonymous SNP,if indel causes frameshift)\nThe binary equivalent of a VCF file is BCF\nExtensions: .vcf , .bcf\n\nExample VCF Format:\n##fileformat=VCFv4.2\n##reference=GRCh37\n##INFO=&lt;ID=AB,Number=A,Type=Float,Description=\"Allele balance at heterozygous sites: a number between 0 and 1 representing the ratio of reads showing the reference allele to all reads, considering only reads from individuals called as heterozygous\"&gt;\n##INFO=&lt;ID=AO,Number=A,Type=Integer,Description=\"Count of full observations of this alternate haplotype.\"&gt;\n##INFO=&lt;ID=DP,Number=1,Type=Integer,Description=\"Total read depth at the locus\"&gt;\n##INFO=&lt;ID=QA,Number=A,Type=Integer,Description=\"Alternate allele quality sum in phred\"&gt;\n##INFO=&lt;ID=QR,Number=1,Type=Integer,Description=\"Reference allele quality sum in phred\"&gt;\n##INFO=&lt;ID=RO,Number=1,Type=Integer,Description=\"Count of full observations of the reference haplotype.\"&gt;\n##FORMAT=&lt;ID=GT,Number=1,Type=String,Description=\"Genotype\"&gt;\n##FORMAT=&lt;ID=DP,Number=1,Type=Integer,Description=\"Read Depth\"&gt;\n##FORMAT=&lt;ID=RO,Number=1,Type=Integer,Description=\"Reference allele observation count\"&gt;\n##FORMAT=&lt;ID=QR,Number=1,Type=Integer,Description=\"Sum of quality of the reference observations\"&gt;\n##FORMAT=&lt;ID=AO,Number=A,Type=Integer,Description=\"Alternate allele observation count\"&gt;\n##FORMAT=&lt;ID=QA,Number=A,Type=Integer,Description=\"Sum of quality of the alternate observations\"&gt;\n##FORMAT=&lt;ID=GL,Number=G,Type=Float,Description=\"Genotype Likelihood, log10-scaled likelihoods of the data given the called genotype for each possible genotype generated from the reference and alternate alleles given the sample ploidy\"&gt;\n#CHROM  POS ID  REF ALT QUAL    FILTER  INFO    FORMAT\nNZ_CP019184.1   39681   .   T   A   682.658 .   AB=0;AO=20;DP=20;QA=780;QR=0;RO=0;TYPE=snp  GT:DP:RO:QR:AO:QA:GL    \nNZ_CP019184.1   40836   .   A   G   682.658 .   AB=0;AO=20;DP=20;QA=780;QR=0;RO=0;TYPE=snp  GT:DP:RO:QR:AO:QA:GL    \nNZ_CP019184.1   48112   .   A   G   682.658 .   AB=0;AO=20;DP=20;QA=780;QR=0;RO=0;TYPE=snp  GT:DP:RO:QR:AO:QA:GL"
  },
  {
    "objectID": "module1.html#working-with-files-in-the-terminal",
    "href": "module1.html#working-with-files-in-the-terminal",
    "title": "Module 1: Bash terminal basics",
    "section": "Working with files in the terminal",
    "text": "Working with files in the terminal\nNow that we went through some common file formats we will be working with, let’s now learn how to manipulate and extract these files from the terminal.\n\nStandard output redirection\nWhen you enter any command in the terminal and see the output on your screen - this output is called the standard output or stdout . For eg: the ls command lists the files and folders in the current directory. Everything that is listed is the stdout\nls \n\ndir1\ndir2\nexample.txt\nThe stdout of any command can be redirected into a file using &gt;.\nls &gt; list_of_files.txt\nNote that there is no stdout printed this time. This is because we redirected the stdout into list_of_files.txt. Now you can see the contents of list_of_files.txt using the cat command that we learned before.\ncat list_of_files.txt\n\ndir1\ndir2\nexample.txt\n\n\n\n\n\n\nTHE &gt; REDIRECTION IS DANGEROUS\n\n\n\nBe very careful when writing a to file with &gt; as if you happen to specify an existing file, it will OVERWRITE all the contents of the existing file with whatever you are redirecting into it. This process is IRREVERSIBLE and you will lose all the original contents of the file. If you want to append (or add to) an existing file, you can use &gt;&gt; and it will add new lines instead of overwriting the existing lines.\n\n\nIt is also possible to redirect the stdout of one command into the input of another command using the “pipe” characer - |. This process is called piping. For example, lets redirect the output of ls to a new command wc . wc prints the number of lines, words, and characters present in the given input. In this case, the input would be whatever the ls command outputs. Here, wc is telling us that there are 3 lines, 3 words and 22 characters.\nls | wc\n\n3  3  22\nPerforming the above command is basically the same as performing:\nls &gt; list_of_files.txt\nwc list_of_files.txt\nBut by using piping, we were able to do it much faster and without writing a new file.\n\n\nExtracting specific information\nThe grep command will search for a string (a specific piece of alphanumeric text) within a plain-text file. It is similar to the ctrl + F or find feature that you many have commonly used to search for text within documents. For example, if we want to search for the string dir in list_of_files.txt, we can do\ngrep \"dir\" list_of_files.txt\n\ndir1\ndir2\ngrep by default will output ALL lines containing the matching string. The string matching is CASE-SENSITIVE, therefore grepping for the string Dir in this case will give an empty result. However if you want grep to perform a CASE-INSENSITIVE search, you can do:\ngrep -i \"Dir\" list_of_files.txt\n\ndir1\ndir2\nIn the above example, grep ignores the case of the string to be searched. There are many such useful modifiers, check man grep or grep --help to see the different behaviours. Another useful modifier is -v for INVERTED matching. This will output only lines that DO NOT HAVE the search string.\ngrep -v \"dir\" list_of_files.txt\n\nexample.txt\nIf grep is similar to the find operation, then sed is the equivalent of find + replace. sed can substitute a specific character, string or pattern with another. By default, sed will replace the first occurrence of the search string in each line. The syntax for sed substitutions is as follows:\nsed 's/search_string/replace_string/' filename\nLets say we want to replace dir in list_of_files.txt with Directory\nsed 's/dir/Directory/` list_of_files.txt\n\nDirectory1\nDirectory2\nexample.txt\nNote that sed is simply performing the specified action in the stdout. It is not actually changing the text within list_of_files.txt. If you would like to REWRITE list_of_files.txt with the specified action, you can perform an in-place substitution with the -i modifier in sed. THIS IS IRREVERSIBLE.\nsed -i 's/dir/Directory/` list_of_files.txt\n\ncat list_of_files.txt\n\nDirectory1\nDirectory2\nexample.txt\n\n\n\n\n\n\nTHE SAME MODIFIER CAN MEAN DIFFERENT THINGS\n\n\n\nBoth grep and sed have the -i modifier, however in grep it means to perform case-insensitive matches, while in sed it means to perform the substitution in-place. It is very important to note that the same modifier can mean different things for different tools. It is always a good idea to check the help page for each tool. How will you perform a case-insensitive substitution in sed ?\n\n\nAnother useful command is tr or translate . While it is similar to sed in that it performs find+replace tasks, tr is faster and easier to use for character-by-character operations, while sed is better for longer strings. For example, if you want to replace a single character with another, tr can do it very easily. For example, lets pipe the sed output to tr to convert Directory into directory\nsed 's/dir/Directory/` list_of_files.txt |  tr 'D' 'd'\n\ndirectory1\ndirectory2\nexample.txt\nIn the above command, tr looks for all instances of D and converts it into d. While this can be done with sed, sed by default only performs operations for the FIRST INSTANCE PER LINE. In other words, sed splits your input line by line, and performs the operation independently for each line.\ntr performs the operation on a character by character basis, and therefore can work across different lines, as the newline (or \\n - which is the character that actually represents a new line) itself is treated as just another character. This allows you to do operations such as the one below very easily.\nsed 's/dir/Directory/` list_of_files.txt |  tr '\\n' '\\s'\n\nDirectory1 Directory2 example.txt\nHere, we replaced all newline characters (\\n) with spaces (\\s)\n\n\nWorking with bioinformatics data\nLets download some real bioinformatics data and see how we can use what we have learned so far.\nActivate your conda environment so that the necessary bioinformatics packages are loaded. See Module0: Setup for more information.\nconda activate NWU_2025_workshop\nDownload a genome fasta file using NCBI’s datasets tool. The datasets tool should already be installed in the conda environment. You can see how to use the datasets tool by typing datasets --help . To download a genome for a specific accession number, the command is :\ndatasets download genome accession GCA_049744075.1\nThis will download a zipped archive from NCBI. Lets extract the archive using unzip, take the file we need and then remove the rest.\nunzip ncbi_dataset.zip\nmkdir test_datasets\nmv ncbi_dataset/data/GCA_049744075.1/GCA_049744075.1_ASM4974407v1_genomic.fna test_datasets/\nrm -r ncbi_dataset.zip ncbi_dataset # you can keep specifying files/folders after the rm command to remove them all\n\n\nEXERCISE: Perform the following actions on the above fasta file\n\nCount the number of contigs in the fasta file\n\n\n\nClick to reveal answer\n\nThe grep command can be used to count the number of contigs (or sequences) in a FASTA file. Each sequence in a FASTA file starts with a header line (&gt;), so we can grep the &gt; character to get only the header lines, and add the -c flag to grep so that it reports the number of matches.\ngrep -c \"&gt;\" GCA_049744075.1_ASM4974407v1_genomic.fna\nAlternatively, we can also use wc -l to report the number of lines matched, as grep by default outputs all matching lines\ngrep \"&gt;\" GCA_049744075.1_ASM4974407v1_genomic.fna | wc -l\n\n\nExtract only sequence names from the FASTA File and write it to a new file.\n\n\n\nclick to reveal answer\n\nWe can extract only sequence names by grepping the “&gt;” character as done previously, but now we pipe it to sed to remove only the &gt; , keeping only the actual names themselves, and then redirect that output to a new text file.\ngrep \"&gt;\" GCA_049744075.1_ASM4974407v1_genomic.fna | sed 's/&gt;//' &gt; GCA_049744075.1_header_names.txt\n\n\nCount the total number of bases in the FASTA file.\n\n\n\nclick to reveal answer\n\nWe use inverted matching with grep -v to get all lines EXCEPT lines starting with “&gt;”, then we remove all newlines using tr -d, and then use wc to count the number of characters. We have to remove all newlines (\\n) as each \\n is considered a separate character, but here we only want to count the number of nucleotides.\ngrep -v \"&gt;\" GCA_049744075.1_ASM4974407v1_genomic.fna | tr -d '\\n' | wc -c\n\n\nIn silico restriction digestion - how many fragments will you get if you digest your genome with EcoRI?\n\n\n\nclick to reveal answer\n\nThe recognition site for EcoRI is GAATTC . We will only get the DNA sequence from our FASTA file using grep and tr as above, but now pipe it to sed and replace each occurrence of GAATTC with a newline (in effect, “cutting” our DNA), then we count the total number of lines\ngrep -v \"&gt;\" GCA_049744075.1_ASM4974407v1_genomic.fna | tr -d '\\n' | sed 's/GAATTC/\\n/g' | wc -l"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pathogen genomics workshop",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\nThis page is under construction"
  },
  {
    "objectID": "module0.html",
    "href": "module0.html",
    "title": "Module 0: Setup",
    "section": "",
    "text": "To follow this course, you will need to install a few things."
  },
  {
    "objectID": "module0.html#shell",
    "href": "module0.html#shell",
    "title": "Module 0: Setup",
    "section": "Shell",
    "text": "Shell\n\nWindows\n\nEnable Windows Subsystem for Linux (WSL)\n\nWinkey (⊞) + r to open Windows Run\nType “control panel” and press Enter (↵)\nClick “Programs”\nClick “Turn Windows features on or off”\nCheck boxes for “Virtual machine platform” and “Windows subsystem for Linux”\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis might already be enabled depending on the exact version of windows. If that is your case you can move on to the next step\n\n\n\nInstall a Linux distribution\n\nWinkey (⊞) + r to open Windows Run\nType “powershell” and press Enter (↵)\nIt should display a prompt ending in &gt;\n\nFor example: PS C:\\Users\\username&gt;\n&gt; means the terminal is ready to receive a command\n\nType wsl --update to install the latest update if available\nThen, once &gt; is visible again, type wsl --install -d Debian\nThis will install a distribution of Linux called ‘Debian’ (this will take up roughly 100 Mb of space on your computer)\nOnce the installation completes, it will prompt for a username and password\n\nThe password won’t be visible when you type. Don’t worry, that’s by design.\n\nOnce entered, the Linux terminal will launch with a prompt ending in $\n\nSimilar to &gt; in the Windows terminal, $ means the Linux terminal is ready to receive a command\n\nClose the window\n\n\nThis is how it should look in your terminal:\nPS C:\\Users\\username&gt; wsl --update\nChecking for updates.\nThe most recent version of Windows Subsystem for Linux is already installed.\nPS C:\\Users\\username&gt; wsl --install -d Debian\nInstalling: Debian GNU/Linux\nDebian GNU/Linux has been installed.\nLaunching Debian GNU/Linux...\nInstalling, this may take a few minutes...\nPlease create a default UNIX user account. The username does not need to match your Windows username.\nFor more information visit: https://aka.ms/wslusers\nEnter new UNIX username: your_username\nNew password:\nRetype new password:\npasswd: password updated successfully\nInstallation successful!\nusername@PCname:~$\n\n\n\n\n\n\nNote\n\n\n\nHere we installed Debian, but there are many other Linux distributions available. Ubuntu is the most popular, but we are using Debian because it is lightweight.\n\n\n\nLaunch a dedicated Linux terminal\n\nWinkey (⊞) + r to open Windows Run\nType “Debian” and press Enter (↵)\nA new Terminal window will open running Debian\nThis will be the primary working environment\n\n\n\n\nLinux\n\nOpen the built-in terminal\n\nPress control + alt + T\n\n\n\n\nMacOS\n\nOpen the Mac terminal\n\nPress command + space to open the search bar\nType “terminal” and press return"
  },
  {
    "objectID": "module0.html#installing-conda",
    "href": "module0.html#installing-conda",
    "title": "Module 0: Setup",
    "section": "Installing Conda",
    "text": "Installing Conda\nConda is a package management software that provides a convenient way to install other packages and their required dependencies, as well as manage virtual environments. For this workshop, we will install Miniconda, which comes with conda and a set of other essential packages.\nThe official Miniconda installation instructions can be found here - https://www.anaconda.com/docs/getting-started/miniconda/install\nFeel free to navigate the above website and find the instructions appropriate for your system if you’re comfortable. If not, follow the instructions below.\n\nOpen the terminal and create a new folder called “miniconda” in your home folder\n\nmkdir ~/miniconda\n\n\n\n\n\n\nTip\n\n\n\n\nmkdir : Command to make a new “directory”. “Directory” and “Folder” are functionally the same and can be used interchangeably.\n\n~/ : is the shortcut for your default home directory.\n\nThis can be replaced with the path to any other location on your computer if you want to create a new folder somewhere else instead.\nYou can type echo $HOME and hit Enter to see the true path to your default home directory.\n\nminiconda : name of the new directory we want to create.\nmkdir ~/miniconda : “Make a new directory called miniconda in the location ~/”\n\n\n\n\nNavigate to the newly created miniconda directory\n\ncd ~/miniconda\n\n\n\n\n\n\nTip\n\n\n\n\ncd : Command to “Change directory”, i.e navigate from the current working directory to a different directory.\n\nYou can type pwd and hit Enter to see the path to the current working directory.\nYou can type ls and hit Enter to list the contents of the current directory.\n\n~/miniconda : Path to the directory you want to navigate to\ncd ~/miniconda : “Change the current working directory to the location ~/miniconda`\n\n\n\n\nSelect the installer:\n\nWindows and Linux: Navigate to https://repo.anaconda.com/miniconda/, right-click Miniconda3-latest-Linux-x86_64.sh from the list and copy the link.\n\n\n\n\n\n\nNote\n\n\n\nWindows users will still be using the Linux version as we will be working on WSL (see section Windows) instead of the Windows terminal.\n\n\nMacOS: Navigate tohttps://repo.anaconda.com/miniconda/, right-click Miniconda3-latest-MacOSX-x86_64.sh if you have an INTEL Mac, or right-click Miniconda3-latest-MacOSX-arm64.sh if you have a M Series Mac, and copy the link.\n\n\n\n\n\n\nHow to find out which CPU you have\n\n\n\nType uname -m in your terminal. If it returns x86_64, you have Intel. Otherwise, you have M series\n\n\n\nDownload the miniconda installer; type curl , and then paste the link you copied. For example, if you copied the “Miniconda3 Linux 64-bit” link, then the command will be\n\ncurl -O https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\n\n\n\n\n\nTip\n\n\n\n\ncurl : Command for retrieving data from URLs\n-O : Activates the O flag, which means the contents of the file in the specified URL will be saved with the same name\n\nTo see the list of all possible options and their explanations for curl, type man curl and hit enter. This will open the “Manual” for the curl command.\n\nhttps://.... : Link to the file to download\ncurl -O https://... - “Download the corresponding file from this URL”\n\n\n\nThis will download a file with the extension .sh, which signifies that it is a bash script.\n\nExecute the downloaded bash script. For example, if you downloaded the Miniconda3-latest-Linux-x86_64.sh file, the commands will be:\n\nbash Miniconda3-latest-Linux-x86_64.sh -u -b -p ~/miniconda/\n\n\n\n\n\n\nTip\n\n\n\n\nbash : Command to execute the bash script\nscript_name.sh : Name of the script to execute; in our case, the name of the script is Miniconda3-latest-Linux-x86_64.sh . You can then optionally specify flags unique to the script being executed. In the case of our script,\n\n-u : Activates the “Update” flag; updates an existing directory with new contents\n-b : Activates the “Batch” flag, which will execute the script without requiring any prompts from the user. You can run the above command without -b to see what that looks like.\n-p : Activates the “Prefix” flag; unlike the previous flags this one requires an input. Here, it is the prefix to be added to the new content that will be created. We specified ~/miniconda/ as the prefix, meaning all new files created by this script will be in the location ~/miniconda\n\n\n\n\nThis would install conda and a number of other packages. Typing ls ~/miniconda/ will show you the new contents that have been created in the folder.\n\nNext, run the following to “initialise” conda:\n\n~/miniconda/bin/conda init\nThis makes executing conda commands simpler and faster. Read more about initialization here:\n\nClose and reopen the terminal.\nEnter conda -V ; if the installation went correctly, you should see the conda version number. For example:\n\nconda 25.7.0"
  },
  {
    "objectID": "module0.html#setting-up-the-conda-environment",
    "href": "module0.html#setting-up-the-conda-environment",
    "title": "Module 0: Setup",
    "section": "Setting up the conda environment",
    "text": "Setting up the conda environment\nNext we will set up a conda virtual ‘environment’ - think of this as a box inside your computer where all the software you need for a particular project is contained. If you have multiple projects, you can set up multiple independent boxes that will not interfere with each other. This also allows you to simultaneously maintain different versions of the same software if you need to.\nFor the workshop, we have created a conda environment with many standard bioinformatics packages (available here). You can use the following command to load this environment onto your computer.\nconda config --set channel_priority flexible\n\nconda env create -f NWU_2025_workshop.yml\nThe environment can be activated with the following command:\nconda activate NWU_2025_workshop\n\n\n\n\n\n\nNote\n\n\n\nYou must activate an environment before you are able to use the tools within that environment. By default, you will be on the base environment. While it is fine to install packages while in the base environment, it can soon get crowded with multiple conflicting packages and lead to issues later down the line. Therefore it is good practice to keep the base environment as clean as possible while creating separate environments for different tools/projects. You can deactivate the current environment and go back to base using the command:\nconda deactivate"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This page is under construction"
  },
  {
    "objectID": "module2.html",
    "href": "module2.html",
    "title": "Working with Files, Text, and Output",
    "section": "",
    "text": "Every file on your computer has a file extension, which is part of its name and comes after the last period (dot) in the filename. For example, in document.txt, .txt is the file extension.\nFile extensions are used by the operating system to determine what kind of file it is, what program should open it, and how it should be processed. Some common file extensions include:\n\n.txt – Plain text file\n.docx – Microsoft Word document\n.pdf – PDF document\n.jpg – JPEG image file\n.sh – Shell script\n\n\n\nFile extensions are important because they help the system identify how to handle a file. For example: - A .txt file is usually opened with a simple text editor (e.g., Notepad, VSCode, etc.). - A .docx file is typically opened in Microsoft Word or similar word processing software.\n\n\n\n\n\n\nNote\n\n\n\nThe extension does not determine the content of a file, just how it is generally interpreted by the system. You can change a file extension, but it doesn’t change the underlying content type though it might prevent the file from being opened correctly. For example you can change the extension of a .jpg image to .txt , but that doesn’t mean you can open it in Notepad as it will still be an image."
  },
  {
    "objectID": "module2.html#files-and-file-extensions",
    "href": "module2.html#files-and-file-extensions",
    "title": "Working with Files, Text, and Output",
    "section": "",
    "text": "Every file on your computer has a file extension, which is part of its name and comes after the last period (dot) in the filename. For example, in document.txt, .txt is the file extension.\nFile extensions are used by the operating system to determine what kind of file it is, what program should open it, and how it should be processed. Some common file extensions include:\n\n.txt – Plain text file\n.docx – Microsoft Word document\n.pdf – PDF document\n.jpg – JPEG image file\n.sh – Shell script\n\n\n\nFile extensions are important because they help the system identify how to handle a file. For example: - A .txt file is usually opened with a simple text editor (e.g., Notepad, VSCode, etc.). - A .docx file is typically opened in Microsoft Word or similar word processing software.\n\n\n\n\n\n\nNote\n\n\n\nThe extension does not determine the content of a file, just how it is generally interpreted by the system. You can change a file extension, but it doesn’t change the underlying content type though it might prevent the file from being opened correctly. For example you can change the extension of a .jpg image to .txt , but that doesn’t mean you can open it in Notepad as it will still be an image."
  },
  {
    "objectID": "module2.html#plain-text-files-and-file-formats-in-bioinformatics",
    "href": "module2.html#plain-text-files-and-file-formats-in-bioinformatics",
    "title": "Working with Files, Text, and Output",
    "section": "Plain Text Files and File Formats in Bioinformatics",
    "text": "Plain Text Files and File Formats in Bioinformatics\n\nWhat is Plain Text?\nPlain text files contain only characters. There are no special formatting, images, or embedded metadata.\nPlain text is UNIVERSAL. It is not a proprietary format that can only be read by specific programme (for example, .docx). Any text editor across any system can read and manipulate plain text files.\nIn bioinformatics, plain text files are preferred for storing data because they can be easily read, processed, and manipulated by a variety of different software.\nHowever, not all bioinformatics data comes in plain text. Many data formats are designed for efficient storage, performance, or specific analysis tasks, and they may be binary formats (e.g., BAM). In bioinformatics workflows, plain text formats are still commonly used for various data exchange and reporting.\n\n\nCommon File Formats in Bioinformatics\nHere are some of the most common file formats used in bioinformatics:\n\n\n\n1. FASTA (Plain Text)\nFASTA is one of the most widely used formats for representing biological sequences, such as DNA, RNA, or protein sequences. A FASTA file consists of multiple sequences, each starting with a description line (prefixed by a &gt;), followed by the sequence itself.\nExample FASTA Format:\n&gt;seq1\nATGCGTACGTAGCTAGCTGATCGTAGCTGACTGATCGTAGC\n&gt;seq2\nGTAGCTAGGCTAGCTAGCTAGTAGGCTAGGAGTAGAGCTAG\n\nDescription line: Starts with &gt;, followed by an identifier and optional description.\nSequence: The actual sequence of nucleotides (DNA) or amino acids (protein).\n\nUse Case: FASTA files are often used to store reference genomes, transcript sequences, or protein sequences.\n\n\n\n2. FASTQ (Plain Text)\nThe FASTQ format is an extension of the FASTA format, used for storing raw sequence data with quality scores. Each entry contains four lines:\n\nHeader: Starts with @ followed by the sequence identifier.\nSequence: The actual sequence of nucleotides (e.g., DNA sequence).\nPlus line: A + sign.\nQuality scores: Encoded as ASCII characters representing the quality of each base.\n\nExample FASTQ Format:\n@seq1\nATGCGTACGTAGCTAGCTGATCGTAGCTGACTGATCGTAGC\n+\nIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n@seq2\nGTAGCTAGGCTAGCTAGCTAGTAGGCTAGGAGTAGAGCTAG\n+\nIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n\nThe quality score lines represent the reliability of each base, encoded in a way that ranges from high to low confidence.\n\nUse Case: FASTQ files are the output of high-throughput sequencing technologies like Illumina and Nanopore. They are often used in raw sequence analysis, quality control, and alignment steps.\n\n\n\n3. SAM/BAM (Plain Text vs. Binary)\n\nSAM (Sequence Alignment/Map) is a plain text format for storing information about sequence alignment. It contains information about the alignment of sequences to a reference genome, including positions, CIGAR strings, mapping quality, and more.\nBAM is the binary equivalent of SAM, designed for efficient storage and quick access.\n\nExample SAM Format:\n@SQ   SN:seq1 LN:1000\nr001  99  seq1  1  60  8S12M1S  * 0  0  GATCGGAAGAGC  *\nr002  0   seq1  2  60  10M  * 0  0  CCTGGAAGAGC  *\nUse Case: SAM/BAM files store mapped sequence data (e.g., after aligning FASTQ reads to a reference genome). They are used in downstream bioinformatics analysis like variant calling or visualization in genome browsers.\n\n\n\n4. VCF (Variant Call Format)\nVCF is a plain text format used to store genetic variation data (e.g., SNPs, indels). It contains metadata and a table of variant calls for each sample at each position in the genome.\nExample VCF Format:\n##fileformat=VCFv4.2\n##reference=GRCh37\n#CHROM POS ID REF ALT QUAL FILTER INFO\nchr1  101  rs12345 A  G  50  PASS  DP=100;AF=0.45\nchr1  202  rs67890 T  C  60  PASS  DP=80;AF=0.60\n\nHeader lines: Provide metadata, such as the reference genome.\nData lines: Contain information about each variant, including chromosome, position, reference allele, alternate allele, and quality metrics.\n\nUse Case: VCF files are commonly used to store variant calls from sequencing data after alignment and variant calling."
  },
  {
    "objectID": "module2.html#working-with-bioinformatics-file-formats-in-the-terminal",
    "href": "module2.html#working-with-bioinformatics-file-formats-in-the-terminal",
    "title": "Working with Files, Text, and Output",
    "section": "Working with Bioinformatics File Formats in the Terminal",
    "text": "Working with Bioinformatics File Formats in the Terminal\nNow that we understand some common bioinformatics file formats, let’s explore how to manipulate and extract useful information from these files using basic shell commands, like grep, sed, and redirection.\n\nStandard Output Redirection with Bioinformatics Files\n\n1. Counting Contigs in a FASTA File\nThe grep command can be used to count the number of contigs (or sequences) in a FASTA file. Each sequence in a FASTA file starts with a description line (&gt;), so we can count the number of &gt; symbols to determine how many sequences (contigs) there are.\n\nCount the number of sequences in a FASTA file:\n\ngrep -c \"&gt;\" sequences.fasta\nThis command counts how many lines start with &gt;, which indicates the number of sequences in the file.\n\n\n2. Extracting Sequence Names from a FASTA File\nIf you want to list just the sequence names (the lines starting with &gt;), you can use grep to extract them.\n\nExtract sequence names (headers) from a FASTA file:\n\ngrep \"&gt;\" sequences.fasta &gt; sequence_names.txt\nThis command will save all sequence names (headers) to sequence_names.txt.\n\n\n3. Working with Quality Scores in FASTQ\nIf you want to extract specific quality scores or sequences from a FASTQ file, you can use grep and sed for pattern matching and modification.\n\nExtract sequences that contain a specific nucleotide (e.g., “A”) in a FASTQ file:\n\ngrep -B 1 \"A\" sample.fastq | grep -v \"^+\"\nThis command looks for sequences containing “A” and shows the associated headers and quality scores.\n\n\n4. Modifying Quality Scores with sed\nSuppose you want to replace low-quality base calls (represented by a specific ASCII character) in a FASTQ file.\n\nReplace low-quality base calls in a FASTQ file (assuming I is a low-quality base):\n\nsed 's/I/N/g' input.fastq &gt; modified.fastq\nThis command replaces all occurrences of I with N in input.fastq and saves the result to modified.fastq."
  },
  {
    "objectID": "module2.html#using-grep-sed-and-piping-in-bioinformatics-workflows",
    "href": "module2.html#using-grep-sed-and-piping-in-bioinformatics-workflows",
    "title": "Working with Files, Text, and Output",
    "section": "Using grep, sed, and Piping in Bioinformatics Workflows",
    "text": "Using grep, sed, and Piping in Bioinformatics Workflows\n\n1. Extracting Variants from a VCF File\nIf you want to filter and extract specific variants from a VCF file, you can use grep or awk. For example, to extract variants from a specific chromosome:\n\nExtract variants from chromosome 1:\n\ngrep \"^chr1\" variants.vcf &gt; chr1_variants.vcf\nYou can also combine commands using piping (|).\n\n\n2. Counting Specific Alleles in a VCF File\nLet’s say you want to count the number of variants with a specific allele (e.g., alternate allele G).\n\nCount the number of variants with the G allele in a VCF file:\n\ngrep -c \"G\" variants.vcf\n\n\n3. Cleaning a VCF File\nYou might want to remove comments or unnecessary lines from a VCF file. You can use grep with the -v option to exclude comment lines.\n\nRemove comment lines from a VCF file:\n\ngrep -v \"^#\" variants.vcf &gt; clean_variants.vcf\nThis removes all lines that start with #, which are typically comments in VCF files."
  }
]