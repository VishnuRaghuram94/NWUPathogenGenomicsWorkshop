[
  {
    "objectID": "module1.html",
    "href": "module1.html",
    "title": "Module 1: Bash terminal basics",
    "section": "",
    "text": "This module will cover the basics of navigating the bash terminal"
  },
  {
    "objectID": "module1.html#exploring-the-file-system",
    "href": "module1.html#exploring-the-file-system",
    "title": "Module 1: Bash terminal basics",
    "section": "Exploring the file system",
    "text": "Exploring the file system\nTo ‘move’ around your computer, typically you would use the built-in file explorer, where you would point and click to navigate through different files and folders.\nWe can also perform the same actions from the terminal by simply typing out the PATH to each file or folder\nThe PATH to a file is the exact location of that file on the computer.\nIt is very important to know at all times exactly where you are in the file system as well as where the files you are working with are.\n\nThe working directory\nOpen the terminal and create an empty file\ntouch example.txt\nWe created a file called example.txt using the touch command. Here, we simply specified the name of the file to be created, but did NOT specify where the file should be created. This means, the file got created in the WORKING DIRECTORY.\nIf you are creating or referring to a file without specifying the PATH , your computer will assume you are pointing to the current WORKING DIRECTORY.\nThe WORKING DIRECTORY refers to the directory you are currently in.\nThe WORKING DIRECTORY can also be signified as ./ .\nWhile ./ will always point to the current WORKING DIRECTORYy, it is merely a shorthand that is referring to the actual PATH to your WORKING DIRECTORY directory.\nThe pwd command or ‘Print Working Directory’ prints the path to the current working directory. It might look something like this\npwd\n/mnt/c/Users/username/project\n\nThe path to any location always starts with / which signifies the root directory. The root is the starting location and it is as far back in the filesystem as you can go.\nIf you imagine the filesystem as a tree with each branch being a different folder, the root directory is the base of the tree trunk\nFrom the root directory /, we are inside the directory mnt, followed by c, followed by Users and so on.\nWhen we created example.txt, we created it from the project directory.\nThis means, the PATH to example.txt is\n\n/mnt/c/Users/username/project/example.txt\n\n\n\n\n\n\nDirectory vs. Folder\n\n\n\nBoth are generally used interchangably though directory is the technically correct term.\n\n\n\n\nThe home directory\nWhen you open your terminal, your default location will be your HOME directory\nThis can be signified as ~/ .\nWhile ~/ will always point to your default HOME directory, it is merely a shorthand that is referring to the actual PATH to your HOME directory.\nThis path can be seen using:\necho $HOME\n/mnt/c/Users/username\n\nThe echo command simply prints out the following text\n$HOME refers to the built-in variable called HOME\n$HOME contains a value, which is the path to your HOME directory\nIn this case, my home directory is /mnt/c/Users/username\nSo if I want to point to example.txt, another way for me to do it is:\n\n~/project/example.txt\n\n\nChanging directories\nThe cd command (or “change directory”) allows you to move between different directories\nFor example, if we would like to move to our home directory, we can type\ncd ~/\n\n\n\n\n\n\nNote\n\n\n\nIn the above example, you would directly move to your home directory no matter where in the filesystem you were, as ~/ always refers to your home directory.\n\n\nNow our current working directory is our home directory.\nIf we would like to switch to the project directory, we can type\ncd project\nWe can move out one level from the current working directory using ../ . Similar to how ./ always refers to the current directory, ../ always refers to one directory above the current directory.\nFor example, if our current directory is /mnt/c/Users/username/project/\ncd ../\npwd\n/mnt/c/Users/username/\ncd ../ takes us one directory above project, which in this case is username. If we were to repeat this, we would go up one more directory, taking us to Users:\ncd ../\npwd\n/mnt/c/Users/\nTherefore ./ and ../ are shorthands that refer to paths that change depending on the current working directory. In other words, they are RELATIVE .\n\nAbsolute vs. Relative Paths\nThere are two main types of paths when referring to files and directories: ABSOLUTE and RELATIVE paths.\nAbsolute Paths always start from the root directory / and specify the exact location of a file or folder in the filesystem. For example, the absolute path to example.txt is:\n/mnt/c/Users/username/project/example.txt\nRelative Paths are paths that are relative to the current working directory. For instance, if you are currently in the username directory, you can refer to example.txt by:\n./project/example.txt\nIf you are in project , and you want to refer to another file another_example.txt that is in Users, you can refer to it relative to your current location such as\n../../another_example.txt\n../../ goes two levels above project to reach Users and then refers to another_example.txt .\n\n\n\n\n\n\nWhy You Should Practice Using Absolute Paths\n\n\n\nIt’s generally a good idea to use absolute paths when you’re working with files or directories, especially when writing scripts or commands that could be run from different locations. This ensures that you are always referring to the exact file, no matter where you are in the filesystem.\n\n\n\n\n\nOther useful commands\nmkdir : Makes a new directory called my_new_folder in the current directory (project)\nmkdir my_new_folder\ncp : Creates a copy of a file. The below example copies example.txt from project to my_new_folder.\ncp example.txt ./my_new_folder/  \nmv : Moves a file from one location to another. The below example moves example.txt from project to username (In this case, one directory above project using ../ ).\nmv example.txt ../  \nls : Lists all files in the specified directory. In the below example we refer to my_new_folder using the absolute path and we list all the files within it, which in this case is only example.txt\nls /mnt/c/Users/username/project/my_new_folder/\n\nexample.txt\nrm : Removes (delete) a specified file. In the below example we delete example.txt in my_new_folder\nrm /mnt/c/Users/username/project/my_new_folder/example.txt\n\n\n\n\n\n\nREMOVING IS PERMANENT\n\n\n\nBe very careful when using the rm command as there will be no confirmation dialogue box asking you if you are sure you want to delete the file as you might be used to. The file will simply PERMANENTLY be deleted!\n\n\nman: Shows the manual (help) page for any command. You can also follow any command with either -h or --help to display the help page. Look up the help page of the above commands to see all the different ways they can be used!\nls --help\nFeel free to experiment with the above commands, navigating between different folders, creating and moving files, using absolute and relative paths and so on.\nYou can also add modifiers to each command to slightly change its behaviour. For example ls simply lists the names of all the files in the specified directory but ls -l lists them with a lot more additional information! Make sure to look into the --help pages for the commands to know more."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pathogen genomics workshop",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\nThis page is under construction"
  },
  {
    "objectID": "module0.html",
    "href": "module0.html",
    "title": "Module 0: Setup",
    "section": "",
    "text": "To follow this course, you will need to install a few things."
  },
  {
    "objectID": "module0.html#shell",
    "href": "module0.html#shell",
    "title": "Module 0: Setup",
    "section": "Shell",
    "text": "Shell\n\nWindows\n\nEnable Windows Subsystem for Linux (WSL)\n\nWinkey (⊞) + r to open Windows Run\nType “control panel” and press Enter (↵)\nClick “Programs”\nClick “Turn Windows features on or off”\nCheck boxes for “Virtual machine platform” and “Windows subsystem for Linux”\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis might already be enabled depending on the exact version of windows. If that is your case you can move on to the next step\n\n\n\nInstall a Linux distribution\n\nWinkey (⊞) + r to open Windows Run\nType “powershell” and press Enter (↵)\nIt should display a prompt ending in &gt;\n\nFor example: PS C:\\Users\\username&gt;\n&gt; means the terminal is ready to receive a command\n\nType wsl --update to install the latest update if available\nThen, once &gt; is visible again, type wsl --install -d Debian\nThis will install a distribution of Linux called ‘Debian’ (this will take up roughly 100 Mb of space on your computer)\nOnce the installation completes, it will prompt for a username and password\n\nThe password won’t be visible when you type. Don’t worry, that’s by design.\n\nOnce entered, the Linux terminal will launch with a prompt ending in $\n\nSimilar to &gt; in the Windows terminal, $ means the Linux terminal is ready to receive a command\n\nClose the window\n\n\nThis is how it should look in your terminal:\nPS C:\\Users\\username&gt; wsl --update\nChecking for updates.\nThe most recent version of Windows Subsystem for Linux is already installed.\nPS C:\\Users\\username&gt; wsl --install -d Debian\nInstalling: Debian GNU/Linux\nDebian GNU/Linux has been installed.\nLaunching Debian GNU/Linux...\nInstalling, this may take a few minutes...\nPlease create a default UNIX user account. The username does not need to match your Windows username.\nFor more information visit: https://aka.ms/wslusers\nEnter new UNIX username: your_username\nNew password:\nRetype new password:\npasswd: password updated successfully\nInstallation successful!\nusername@PCname:~$\n\n\n\n\n\n\nNote\n\n\n\nHere we installed Debian, but there are many other Linux distributions available. Ubuntu is the most popular, but we are using Debian because it is lightweight.\n\n\n\nLaunch a dedicated Linux terminal\n\nWinkey (⊞) + r to open Windows Run\nType “Debian” and press Enter (↵)\nA new Terminal window will open running Debian\nThis will be the primary working environment\n\n\n\n\nLinux\n\nOpen the built-in terminal\n\nPress control + alt + T\n\n\n\n\nMacOS\n\nOpen the Mac terminal\n\nPress command + space to open the search bar\nType “terminal” and press return"
  },
  {
    "objectID": "module0.html#installing-conda",
    "href": "module0.html#installing-conda",
    "title": "Module 0: Setup",
    "section": "Installing Conda",
    "text": "Installing Conda\nConda is a package management software that provides a convenient way to install other packages and their required dependencies, as well as manage virtual environments. For this workshop, we will install Miniconda, which comes with conda and a set of other essential packages.\nThe official Miniconda installation instructions can be found here - https://www.anaconda.com/docs/getting-started/miniconda/install\nFeel free to navigate the above website and find the instructions appropriate for your system if you’re comfortable. If not, follow the instructions below.\n\nOpen the terminal and create a new folder called “miniconda” in your home folder\n\nmkdir ~/miniconda\n\n\n\n\n\n\nTip\n\n\n\n\nmkdir : Command to make a new “directory”. “Directory” and “Folder” are functionally the same and can be used interchangeably.\n\n~/ : is the shortcut for your default home directory.\n\nThis can be replaced with the path to any other location on your computer if you want to create a new folder somewhere else instead.\nYou can type echo $HOME and hit Enter to see the true path to your default home directory.\n\nminiconda : name of the new directory we want to create.\nmkdir ~/miniconda : “Make a new directory called miniconda in the location ~/”\n\n\n\n\nNavigate to the newly created miniconda directory\n\ncd ~/miniconda\n\n\n\n\n\n\nTip\n\n\n\n\ncd : Command to “Change directory”, i.e navigate from the current working directory to a different directory.\n\nYou can type pwd and hit Enter to see the path to the current working directory.\nYou can type ls and hit Enter to list the contents of the current directory.\n\n~/miniconda : Path to the directory you want to navigate to\ncd ~/miniconda : “Change the current working directory to the location ~/miniconda`\n\n\n\n\nSelect the installer:\n\nWindows and Linux: Navigate to https://repo.anaconda.com/miniconda/, right-click Miniconda3-latest-Linux-x86_64.sh from the list and copy the link.\n\n\n\n\n\n\nNote\n\n\n\nWindows users will still be using the Linux version as we will be working on WSL (see section Windows) instead of the Windows terminal.\n\n\nMacOS: Navigate tohttps://repo.anaconda.com/miniconda/, right-click Miniconda3-latest-MacOSX-x86_64.sh if you have an INTEL Mac, or right-click Miniconda3-latest-MacOSX-arm64.sh if you have a M Series Mac, and copy the link.\n\n\n\n\n\n\nHow to find out which CPU you have\n\n\n\nType uname -m in your terminal. If it returns x86_64, you have Intel. Otherwise, you have M series\n\n\n\nDownload the miniconda installer; type curl , and then paste the link you copied. For example, if you copied the “Miniconda3 Linux 64-bit” link, then the command will be\n\ncurl -O https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh\n\n\n\n\n\n\nTip\n\n\n\n\ncurl : Command for retrieving data from URLs\n-O : Activates the O flag, which means the contents of the file in the specified URL will be saved with the same name\n\nTo see the list of all possible options and their explanations for curl, type man curl and hit enter. This will open the “Manual” for the curl command.\n\nhttps://.... : Link to the file to download\ncurl -O https://... - “Download the corresponding file from this URL”\n\n\n\nThis will download a file with the extension .sh, which signifies that it is a bash script.\n\nExecute the downloaded bash script. For example, if you downloaded the Miniconda3-latest-Linux-x86_64.sh file, the commands will be:\n\nbash Miniconda3-latest-Linux-x86_64.sh -u -b -p ~/miniconda/\n\n\n\n\n\n\nTip\n\n\n\n\nbash : Command to execute the bash script\nscript_name.sh : Name of the script to execute; in our case, the name of the script is Miniconda3-latest-Linux-x86_64.sh . You can then optionally specify flags unique to the script being executed. In the case of our script,\n\n-u : Activates the “Update” flag; updates an existing directory with new contents\n-b : Activates the “Batch” flag, which will execute the script without requiring any prompts from the user. You can run the above command without -b to see what that looks like.\n-p : Activates the “Prefix” flag; unlike the previous flags this one requires an input. Here, it is the prefix to be added to the new content that will be created. We specified ~/miniconda/ as the prefix, meaning all new files created by this script will be in the location ~/miniconda\n\n\n\n\nThis would install conda and a number of other packages. Typing ls ~/miniconda/ will show you the new contents that have been created in the folder.\n\nNext, run the following to “initialise” conda:\n\n~/miniconda/bin/conda init\nThis makes executing conda commands simpler and faster. Read more about initialization here:\n\nClose and reopen the terminal.\nEnter conda -V ; if the installation went correctly, you should see the conda version number. For example:\n\nconda 25.7.0"
  },
  {
    "objectID": "module0.html#setting-up-the-conda-environment",
    "href": "module0.html#setting-up-the-conda-environment",
    "title": "Module 0: Setup",
    "section": "Setting up the conda environment",
    "text": "Setting up the conda environment\nNext we will set up a conda virtual ‘environment’ - think of this as a box inside your computer where all the software you need for a particular project is contained. If you have multiple projects, you can set up multiple independent boxes that will not interfere with each other. This also allows you to simultaneously maintain different versions of the same software if you need to.\nFor the workshop, we have created a conda environment with many standard bioinformatics packages (available here). You can use the following command to load this environment onto your computer.\nconda config --set channel_priority flexible\n\nconda env create -f NWU_2025_workshop.yml\nThe environment can be activated with the following command:\nconda activate NWU_2025_workshop\n\n\n\n\n\n\nNote\n\n\n\nYou must activate an environment before you are able to use the tools within that environment. By default, you will be on the base environment. While it is fine to install packages while in the base environment, it can soon get crowded with multiple conflicting packages and lead to issues later down the line. Therefore it is good practice to keep the base environment as clean as possible while creating separate environments for different tools/projects. You can deactivate the current environment and go back to base using the command:\nconda deactivate"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This page is under construction"
  },
  {
    "objectID": "module2.html",
    "href": "module2.html",
    "title": "Working with Files, Text, and Output",
    "section": "",
    "text": "Every file on your computer has a file extension, which is part of its name and comes after the last period (dot) in the filename. For example, in document.txt, .txt is the file extension.\nFile extensions are used by the operating system to determine what kind of file it is, what program should open it, and how it should be processed. Some common file extensions include:\n\n.txt – Plain text file\n.docx – Microsoft Word document\n.pdf – PDF document\n.jpg – JPEG image file\n.sh – Shell script\n\n\n\nFile extensions are important because they help the system identify how to handle a file. For example: - A .txt file is usually opened with a simple text editor (e.g., Notepad, VSCode, etc.). - A .docx file is typically opened in Microsoft Word or similar word processing software.\n\n\n\n\n\n\nNote\n\n\n\nThe extension does not determine the content of a file, just how it is generally interpreted by the system. You can change a file extension, but it doesn’t change the underlying content type though it might prevent the file from being opened correctly. For example you can change the extension of a .jpg image to .txt , but that doesn’t mean you can open it in Notepad as it will still be an image."
  },
  {
    "objectID": "module2.html#files-and-file-extensions",
    "href": "module2.html#files-and-file-extensions",
    "title": "Working with Files, Text, and Output",
    "section": "",
    "text": "Every file on your computer has a file extension, which is part of its name and comes after the last period (dot) in the filename. For example, in document.txt, .txt is the file extension.\nFile extensions are used by the operating system to determine what kind of file it is, what program should open it, and how it should be processed. Some common file extensions include:\n\n.txt – Plain text file\n.docx – Microsoft Word document\n.pdf – PDF document\n.jpg – JPEG image file\n.sh – Shell script\n\n\n\nFile extensions are important because they help the system identify how to handle a file. For example: - A .txt file is usually opened with a simple text editor (e.g., Notepad, VSCode, etc.). - A .docx file is typically opened in Microsoft Word or similar word processing software.\n\n\n\n\n\n\nNote\n\n\n\nThe extension does not determine the content of a file, just how it is generally interpreted by the system. You can change a file extension, but it doesn’t change the underlying content type though it might prevent the file from being opened correctly. For example you can change the extension of a .jpg image to .txt , but that doesn’t mean you can open it in Notepad as it will still be an image."
  },
  {
    "objectID": "module2.html#plain-text-files-and-file-formats-in-bioinformatics",
    "href": "module2.html#plain-text-files-and-file-formats-in-bioinformatics",
    "title": "Working with Files, Text, and Output",
    "section": "Plain Text Files and File Formats in Bioinformatics",
    "text": "Plain Text Files and File Formats in Bioinformatics\n\nWhat is Plain Text?\nPlain text files contain only characters. There are no special formatting, images, or embedded metadata.\nPlain text is UNIVERSAL. It is not a proprietary format that can only be read by specific programme (for example, .docx). Any text editor across any system can read and manipulate plain text files.\nIn bioinformatics, plain text files are preferred for storing data because they can be easily read, processed, and manipulated by a variety of different software.\nHowever, not all bioinformatics data comes in plain text. Many data formats are designed for efficient storage, performance, or specific analysis tasks, and they may be binary formats (e.g., BAM). In bioinformatics workflows, plain text formats are still commonly used for various data exchange and reporting.\n\n\nCommon File Formats in Bioinformatics\nHere are some of the most common file formats used in bioinformatics:\n\n\n\n1. FASTA (Plain Text)\nFASTA is one of the most widely used formats for representing biological sequences, such as DNA, RNA, or protein sequences. A FASTA file consists of multiple sequences, each starting with a description line (prefixed by a &gt;), followed by the sequence itself.\nExample FASTA Format:\n&gt;seq1\nATGCGTACGTAGCTAGCTGATCGTAGCTGACTGATCGTAGC\n&gt;seq2\nGTAGCTAGGCTAGCTAGCTAGTAGGCTAGGAGTAGAGCTAG\n\nDescription line: Starts with &gt;, followed by an identifier and optional description.\nSequence: The actual sequence of nucleotides (DNA) or amino acids (protein).\n\nUse Case: FASTA files are often used to store reference genomes, transcript sequences, or protein sequences.\n\n\n\n2. FASTQ (Plain Text)\nThe FASTQ format is an extension of the FASTA format, used for storing raw sequence data with quality scores. Each entry contains four lines:\n\nHeader: Starts with @ followed by the sequence identifier.\nSequence: The actual sequence of nucleotides (e.g., DNA sequence).\nPlus line: A + sign.\nQuality scores: Encoded as ASCII characters representing the quality of each base.\n\nExample FASTQ Format:\n@seq1\nATGCGTACGTAGCTAGCTGATCGTAGCTGACTGATCGTAGC\n+\nIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n@seq2\nGTAGCTAGGCTAGCTAGCTAGTAGGCTAGGAGTAGAGCTAG\n+\nIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n\nThe quality score lines represent the reliability of each base, encoded in a way that ranges from high to low confidence.\n\nUse Case: FASTQ files are the output of high-throughput sequencing technologies like Illumina and Nanopore. They are often used in raw sequence analysis, quality control, and alignment steps.\n\n\n\n3. SAM/BAM (Plain Text vs. Binary)\n\nSAM (Sequence Alignment/Map) is a plain text format for storing information about sequence alignment. It contains information about the alignment of sequences to a reference genome, including positions, CIGAR strings, mapping quality, and more.\nBAM is the binary equivalent of SAM, designed for efficient storage and quick access.\n\nExample SAM Format:\n@SQ   SN:seq1 LN:1000\nr001  99  seq1  1  60  8S12M1S  * 0  0  GATCGGAAGAGC  *\nr002  0   seq1  2  60  10M  * 0  0  CCTGGAAGAGC  *\nUse Case: SAM/BAM files store mapped sequence data (e.g., after aligning FASTQ reads to a reference genome). They are used in downstream bioinformatics analysis like variant calling or visualization in genome browsers.\n\n\n\n4. VCF (Variant Call Format)\nVCF is a plain text format used to store genetic variation data (e.g., SNPs, indels). It contains metadata and a table of variant calls for each sample at each position in the genome.\nExample VCF Format:\n##fileformat=VCFv4.2\n##reference=GRCh37\n#CHROM POS ID REF ALT QUAL FILTER INFO\nchr1  101  rs12345 A  G  50  PASS  DP=100;AF=0.45\nchr1  202  rs67890 T  C  60  PASS  DP=80;AF=0.60\n\nHeader lines: Provide metadata, such as the reference genome.\nData lines: Contain information about each variant, including chromosome, position, reference allele, alternate allele, and quality metrics.\n\nUse Case: VCF files are commonly used to store variant calls from sequencing data after alignment and variant calling."
  },
  {
    "objectID": "module2.html#working-with-bioinformatics-file-formats-in-the-terminal",
    "href": "module2.html#working-with-bioinformatics-file-formats-in-the-terminal",
    "title": "Working with Files, Text, and Output",
    "section": "Working with Bioinformatics File Formats in the Terminal",
    "text": "Working with Bioinformatics File Formats in the Terminal\nNow that we understand some common bioinformatics file formats, let’s explore how to manipulate and extract useful information from these files using basic shell commands, like grep, sed, and redirection.\n\nStandard Output Redirection with Bioinformatics Files\n\n1. Counting Contigs in a FASTA File\nThe grep command can be used to count the number of contigs (or sequences) in a FASTA file. Each sequence in a FASTA file starts with a description line (&gt;), so we can count the number of &gt; symbols to determine how many sequences (contigs) there are.\n\nCount the number of sequences in a FASTA file:\n\ngrep -c \"&gt;\" sequences.fasta\nThis command counts how many lines start with &gt;, which indicates the number of sequences in the file.\n\n\n2. Extracting Sequence Names from a FASTA File\nIf you want to list just the sequence names (the lines starting with &gt;), you can use grep to extract them.\n\nExtract sequence names (headers) from a FASTA file:\n\ngrep \"&gt;\" sequences.fasta &gt; sequence_names.txt\nThis command will save all sequence names (headers) to sequence_names.txt.\n\n\n3. Working with Quality Scores in FASTQ\nIf you want to extract specific quality scores or sequences from a FASTQ file, you can use grep and sed for pattern matching and modification.\n\nExtract sequences that contain a specific nucleotide (e.g., “A”) in a FASTQ file:\n\ngrep -B 1 \"A\" sample.fastq | grep -v \"^+\"\nThis command looks for sequences containing “A” and shows the associated headers and quality scores.\n\n\n4. Modifying Quality Scores with sed\nSuppose you want to replace low-quality base calls (represented by a specific ASCII character) in a FASTQ file.\n\nReplace low-quality base calls in a FASTQ file (assuming I is a low-quality base):\n\nsed 's/I/N/g' input.fastq &gt; modified.fastq\nThis command replaces all occurrences of I with N in input.fastq and saves the result to modified.fastq."
  },
  {
    "objectID": "module2.html#using-grep-sed-and-piping-in-bioinformatics-workflows",
    "href": "module2.html#using-grep-sed-and-piping-in-bioinformatics-workflows",
    "title": "Working with Files, Text, and Output",
    "section": "Using grep, sed, and Piping in Bioinformatics Workflows",
    "text": "Using grep, sed, and Piping in Bioinformatics Workflows\n\n1. Extracting Variants from a VCF File\nIf you want to filter and extract specific variants from a VCF file, you can use grep or awk. For example, to extract variants from a specific chromosome:\n\nExtract variants from chromosome 1:\n\ngrep \"^chr1\" variants.vcf &gt; chr1_variants.vcf\nYou can also combine commands using piping (|).\n\n\n2. Counting Specific Alleles in a VCF File\nLet’s say you want to count the number of variants with a specific allele (e.g., alternate allele G).\n\nCount the number of variants with the G allele in a VCF file:\n\ngrep -c \"G\" variants.vcf\n\n\n3. Cleaning a VCF File\nYou might want to remove comments or unnecessary lines from a VCF file. You can use grep with the -v option to exclude comment lines.\n\nRemove comment lines from a VCF file:\n\ngrep -v \"^#\" variants.vcf &gt; clean_variants.vcf\nThis removes all lines that start with #, which are typically comments in VCF files."
  }
]